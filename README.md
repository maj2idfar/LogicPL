# LogicPL
A compiler implemented during the programming languages and compilers design course at University of Tehran (Spring 2023)

## What is LogicPL?

LogicPL language is a logical programming language. Programs written in this language include a number of fact and a number of rules (if-then or implication) that can respond to queries. If defined in the Function program, its definition is written before the Facts and Implication rules. A fully explained documentation file in Persian can be found [here](./docs/LogicPL_Persian_Documentation.pdf).

## Phase 1 - Lexical and Syntax Analysis

### Lexical Analysis 

Every keyword of LogicPL is defined and implemented.

### Syntax Analysis

A full grammar for LogicPL is written by defining necassary rules, and some actions are added to print the nodes in pre-order format. Output is generated by tokenizing and parsing the input using [ANTLR](./tools/antlr-4.12.0-complete.jar) tool.

## Phase 2 - AST and Name Analysis

In this phase of project, we worked on a simplefied version of grammar file which can be found [here](/2_AST_and_Name_Analysis/src/src/main/grammar/LogicPL.g4).

### Abstract Syntax Tree (AST)

Some actions are added to the grammar to build the nodes of AST. Then [ASTPrinter](./2_AST_and_Name_Analysis/src/src/visitor/astPrinter/ASTPrinter.java) class is implemented to print AST nodes in pre-order format with the corresponding messages for each one of them.

### Name Analysis

[NameAnalyzer](./2_AST_and_Name_Analysis/src/src/visitor/nameAnalyzer/NameAnalyzer.java) class is implemented to create symbol tree and catch the following errors through parsing the input program:

1. Each variable is defined more than once in each scope.
2. Each function is defined more than once in the program.

## Phase 3 - Type Analysis

### Expression Type Checking

[ExpressionTypeChecker](./3_Type_Analysis/src/src/visitor/typeAnalyzer/ExpressionTypeChecker.java) is implemented to check the mathematical expressions which returns the type of that expression.

### Type Analysis

[TypeAnalyzer](./3_Type_Analysis/src/src/visitor/typeAnalyzer/TypeAnalyzer.java) is implemented to catch the following error:

1. A non-defined variable called. In this case we assume it as NoType.
2. Misuse in operands. For example, we cannot add a boolean and an integer. In this case we assume it as NoType.
3. Condition in implication is not boolean.
4. Function call must be a valid function name that exists in the program. otherwise we assume it NoType.

## Phase 4 - Code Generation

In the final phase of this project, [CodeGenerator](./4_Code_Generation/src/src/visitor/codeGenerator/CodeGenerator.java) is implemented which traverses the generated AST and produces Jasmine Assembly code (`.class` files).

**Note** that this is just a simplified mocked versions of the Java ByteCode and it can not be executed. The output of this phase was just to implement a ByteCode-like logic.